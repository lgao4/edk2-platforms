## @file
#  FDF file of Platform.
#
# Copyright (c) 2017, Intel Corporation. All rights reserved.<BR>
#
# This program and the accompanying materials are licensed and made available under
# the terms and conditions of the BSD License which accompanies this distribution.
# The full text of the license may be found at
# http://opensource.org/licenses/bsd-license.php
#
# THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
# WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
#
##

[Defines]
   !include $(PLATFORM_BOARD_PACKAGE)/Include/Fdf/FlashMapInclude.fdf

################################################################################
#
# FD Section
# The [FD] Section is made up of the definition statements and a
# description of what goes into  the Flash Device Image.  Each FD section
# defines one flash "device" image.  A flash device image may be one of
# the following: Removable media bootable image (like a boot floppy
# image,) an Option ROM image (that would be "flashed" into an add-in
# card,) a System "Flash"  image (that would be burned into a system's
# flash) or an Update ("Capsule") image that will be used to update and
# existing system flash.
#
################################################################################
[FD.KabylakeRvp3]
#
# FD Tokens, BaseAddress, Size, ErasePolarity, BlockSize, and NumBlocks, cannot be
# assigned with PCD values. Instead, it uses the definitions for its variety, which
# are FLASH_BASE, FLASH_SIZE, FLASH_BLOCK_SIZE and FLASH_NUM_BLOCKS.
#
BaseAddress   = $(FLASH_BASE) | gSiPkgTokenSpaceGuid.PcdFlashAreaBaseAddress      #The base address of the FLASH Device.
Size          = $(FLASH_SIZE) | gSiPkgTokenSpaceGuid.PcdFlashAreaSize             #The size in bytes of the FLASH Device
ErasePolarity = 1
BlockSize     = $(FLASH_BLOCK_SIZE)
NumBlocks     = $(FLASH_NUM_BLOCKS)

DEFINE SIPKG_DXE_SMM_BIN  = INF
DEFINE SIPKG_PEI_BIN      = INF

# Set FLASH_REGION_FV_RECOVERY_OFFSET to PcdNemCodeCacheBase, because macro expression is not supported.
# So, PlatformSecLib uses PcdFlashAreaBaseAddress + PcdNemCodeCacheBase to get the real CodeCache base address.
SET gSiPkgTokenSpaceGuid.PcdNemCodeCacheBase = $(gPlatformModuleTokenSpaceGuid.PcdFlashFvRecovery2Offset)
SET gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvBase = $(gSiPkgTokenSpaceGuid.PcdFlashAreaBaseAddress) + $(gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvOffset)
SET gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvSize = $(gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvSize)
SET gUefiCpuPkgTokenSpaceGuid.PcdCpuMicrocodePatchAddress = $(gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvBase) + 0x60
SET gUefiCpuPkgTokenSpaceGuid.PcdCpuMicrocodePatchRegionSize = $(gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvSize) - 0x60
SET gIntelFsp2WrapperTokenSpaceGuid.PcdCpuMicrocodePatchAddress = $(gSiPkgTokenSpaceGuid.PcdFlashAreaBaseAddress) + $(gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvOffset)
SET gIntelFsp2WrapperTokenSpaceGuid.PcdCpuMicrocodePatchRegionSize = $(gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvSize)
SET gIntelFsp2WrapperTokenSpaceGuid.PcdFlashMicrocodeOffset = 0x60
SET gPlatformModuleTokenSpaceGuid.PcdFlashMicrocodeFvBase    = gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvBase
SET gPlatformModuleTokenSpaceGuid.PcdFlashMicrocodeFvSize    = gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvSize
SET gPlatformModuleTokenSpaceGuid.PcdFlashMicrocodeFvOffset  = gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvOffset
SET gIntelFsp2WrapperTokenSpaceGuid.PcdFlashCodeCacheAddress = gSiPkgTokenSpaceGuid.PcdFlashAreaBaseAddress
SET gIntelFsp2WrapperTokenSpaceGuid.PcdFlashCodeCacheSize    = gSiPkgTokenSpaceGuid.PcdFlashAreaSize
SET gPlatformModuleTokenSpaceGuid.PcdFlashAreaBaseAddress = gSiPkgTokenSpaceGuid.PcdFlashAreaBaseAddress
SET gPlatformModuleTokenSpaceGuid.PcdFlashAreaSize        = gSiPkgTokenSpaceGuid.PcdFlashAreaSize
SET gPlatformModuleTokenSpaceGuid.PcdFlashFvFspWrapperBase = $(gSiPkgTokenSpaceGuid.PcdFlashAreaBaseAddress) + $(gPlatformModuleTokenSpaceGuid.PcdFlashFvRecovery3Offset)
SET gPlatformModuleTokenSpaceGuid.PcdFlashFvFspWrapperSize = $(gPlatformModuleTokenSpaceGuid.PcdFlashFvRecovery3Size)
################################################################################
#
# Following are lists of FD Region layout which correspond to the locations of different
# images within the flash device.
#
# Regions must be defined in ascending order and may not overlap.
#
# A Layout Region start with a eight digit hex offset (leading "0x" required) followed by
# the pipe "|" character, followed by the size of the region, also in hex with the leading
# "0x" characters. Like:
# Offset|Size
# PcdOffsetCName|PcdSizeCName
# RegionType <FV, DATA, or FILE>
# Fv Size can be adjusted; FVMAIN_COMPACT can be reduced to 0x120000, and FV_RECOVERY can be enlarged to 0x80000
#
################################################################################
gPlatformModuleTokenSpaceGuid.PcdFlashNvStorageVariableOffset|gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize
gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableBase|gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize
#NV_VARIABLE_STORE
DATA = {
  ## This is the EFI_FIRMWARE_VOLUME_HEADER
  # ZeroVector []
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  # FileSystemGuid
  0x8D, 0x2B, 0xF1, 0xFF, 0x96, 0x76, 0x8B, 0x4C,
  0xA9, 0x85, 0x27, 0x47, 0x07, 0x5B, 0x4F, 0x50,
  # FvLength: 0x40000
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
  #Signature "_FVH"       #Attributes
  0x5F, 0x46, 0x56, 0x48, 0xFF, 0xFE, 0x04, 0x00,
  #HeaderLength #CheckSum #ExtHeaderOffset #Reserved #Revision
  #
  # Be careful on CheckSum field.
  #
  0x48, 0x00, 0x32, 0x09, 0x00, 0x00, 0x00, 0x02,
  #Blockmap[0]: 4 Blocks  0x10000 Bytes / Block
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  #Blockmap[1]: End
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  ## This is the VARIABLE_STORE_HEADER
!if gPlatformModuleTokenSpaceGuid.PcdUefiSecureBootEnable == TRUE
  #  Signature: gEfiAuthenticatedVariableGuid = { 0xaaf32c78, 0x947b, 0x439a, { 0xa1, 0x80, 0x2e, 0x14, 0x4e, 0xc3, 0x77, 0x92 }}
  0x78, 0x2c, 0xf3, 0xaa, 0x7b, 0x94, 0x9a, 0x43,
  0xa1, 0x80, 0x2e, 0x14, 0x4e, 0xc3, 0x77, 0x92,
!else
  #  Signature: gEfiVariableGuid = { 0xddcf3616, 0x3275, 0x4164, { 0x98, 0xb6, 0xfe, 0x85, 0x70, 0x7f, 0xfe, 0x7d }}
  0x16, 0x36, 0xcf, 0xdd, 0x75, 0x32, 0x64, 0x41,
  0x98, 0xb6, 0xfe, 0x85, 0x70, 0x7f, 0xfe, 0x7d,
!endif
  #Size: 0x1E000 (gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize) - 0x48 (size of EFI_FIRMWARE_VOLUME_HEADER) = 0x1DFB8
  # This can speed up the Variable Dispatch a bit.
  0xB8, 0xDF, 0x01, 0x00,
  #FORMATTED: 0x5A #HEALTHY: 0xFE #Reserved: UINT16 #Reserved1: UINT32
  0x5A, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
}

gPlatformModuleTokenSpaceGuid.PcdFlashNvStorageFtwWorkingOffset|gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingSize
gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingBase|gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingSize
#NV_FTW_WORKING
DATA = {
  # EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER->Signature = gEdkiiWorkingBlockSignatureGuid         =
  #  { 0x9e58292b, 0x7c68, 0x497d, { 0xa0, 0xce, 0x65,  0x0, 0xfd, 0x9f, 0x1b, 0x95 }}
  0x2b, 0x29, 0x58, 0x9e, 0x68, 0x7c, 0x7d, 0x49,
  0xa0, 0xce, 0x65,  0x0, 0xfd, 0x9f, 0x1b, 0x95,
  # Crc:UINT32            #WorkingBlockValid:1, WorkingBlockInvalid:1, Reserved
  0xE2, 0x33, 0xF2, 0x03, 0xFE, 0xFF, 0xFF, 0xFF,
  # WriteQueueSize: UINT64
  0xE0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
}

gPlatformModuleTokenSpaceGuid.PcdFlashNvStorageFtwSpareOffset|gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareSize
gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareBase|gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareSize
#NV_FTW_SPARE


gPlatformModuleTokenSpaceGuid.PcdFlashFvMain2Offset|gPlatformModuleTokenSpaceGuid.PcdFlashFvMain2Size
gPlatformModuleTokenSpaceGuid.PcdFlashFvMain2Base|gPlatformModuleTokenSpaceGuid.PcdFlashFvMain2Size
FV = FVMAIN2_COMPACT

gPlatformModuleTokenSpaceGuid.PcdFlashFvMainOffset|gPlatformModuleTokenSpaceGuid.PcdFlashFvMainSize
gPlatformModuleTokenSpaceGuid.PcdFlashFvMainBase|gPlatformModuleTokenSpaceGuid.PcdFlashFvMainSize
FV = FVMAIN_COMPACT

gPlatformModuleTokenSpaceGuid.PcdFlashFvRecovery3Offset|gPlatformModuleTokenSpaceGuid.PcdFlashFvRecovery3Size
gPlatformModuleTokenSpaceGuid.PcdFlashFvRecovery3Base|gPlatformModuleTokenSpaceGuid.PcdFlashFvRecovery3Size
#FvRecovery3
FV = FVRECOVERY3_COMPACT

gPlatformModuleTokenSpaceGuid.PcdFlashFvFspsOffset|gPlatformModuleTokenSpaceGuid.PcdFlashFvFspsSize
gPlatformModuleTokenSpaceGuid.PcdFlashFvFspsBase|gPlatformModuleTokenSpaceGuid.PcdFlashFvFspsSize
# FSP_S Section
FV=FSP_S


gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvOffset|gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvSize
gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvBase|gSiPkgTokenSpaceGuid.PcdFlashMicrocodeFvSize
#Microcode
FV = MICROCODE_FV

gPlatformModuleTokenSpaceGuid.PcdFlashFvRecovery2Offset|gPlatformModuleTokenSpaceGuid.PcdFlashFvRecovery2Size
gPlatformModuleTokenSpaceGuid.PcdFlashFvRecovery2Base|gPlatformModuleTokenSpaceGuid.PcdFlashFvRecovery2Size
#FvRecovery
FV = FVRECOVERY2

gPlatformModuleTokenSpaceGuid.PcdFlashFvFspmtOffset|gPlatformModuleTokenSpaceGuid.PcdFlashFvFspmtSize
gPlatformModuleTokenSpaceGuid.PcdFlashFvFspmtBase|gPlatformModuleTokenSpaceGuid.PcdFlashFvFspmtSize
# FSP_M & T Section
FILE = $(PLATFORM_FSP_BIN_PACKAGE)/Fsp_Rebased_M_T.fd

gPlatformModuleTokenSpaceGuid.PcdFlashFvRecoveryOffset|gPlatformModuleTokenSpaceGuid.PcdFlashFvRecoverySize
gPlatformModuleTokenSpaceGuid.PcdFlashFvRecoveryBase|gPlatformModuleTokenSpaceGuid.PcdFlashFvRecoverySize
#FvRecovery
FV = FVRECOVERY

################################################################################
#
# FV Section
#
# [FV] section is used to define what components or modules are placed within a flash
# device file.  This section also defines order the components and modules are positioned
# within the image.  The [FV] section consists of define statements, set statements and
# module statements.
#
################################################################################
[FV.MICROCODE_FV]
BlockSize     = $(FLASH_BLOCK_SIZE)
FvAlignment        = 16
ERASE_POLARITY     = 1
MEMORY_MAPPED      = TRUE
STICKY_WRITE       = TRUE
LOCK_CAP           = TRUE
LOCK_STATUS        = FALSE
WRITE_DISABLED_CAP = TRUE
WRITE_ENABLED_CAP  = TRUE
WRITE_STATUS       = TRUE
WRITE_LOCK_CAP     = TRUE
WRITE_LOCK_STATUS  = TRUE
READ_DISABLED_CAP  = TRUE
READ_ENABLED_CAP   = TRUE
READ_STATUS        = FALSE
READ_LOCK_CAP      = TRUE
READ_LOCK_STATUS   = TRUE

FILE RAW = 197DB236-F856-4924-90F8-CDF12FB875F3 {
  $(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/X64/MicrocodeUpdates.bin
}



[FV.FSP_S]
BlockSize          = $(FLASH_BLOCK_SIZE)
FvAlignment        = 16         #FV alignment and FV attributes setting.
ERASE_POLARITY     = 1
MEMORY_MAPPED      = TRUE
STICKY_WRITE       = TRUE
LOCK_CAP           = TRUE
LOCK_STATUS        = TRUE
WRITE_DISABLED_CAP = TRUE
WRITE_ENABLED_CAP  = TRUE
WRITE_STATUS       = TRUE
WRITE_LOCK_CAP     = TRUE
WRITE_LOCK_STATUS  = TRUE
READ_DISABLED_CAP  = TRUE
READ_ENABLED_CAP   = TRUE
READ_STATUS        = TRUE
READ_LOCK_CAP      = TRUE
READ_LOCK_STATUS   = TRUE

FILE FV_IMAGE = 3417F275-4CF1-42D8-A0C3-B3F60779dF4D  {
# Use Padded file which adds 0xC bytes of data (Note: Section will add 4 bytes of SECTION Header). This is done to align the FSP Header to 16 bytes
  SECTION RAW = $(PLATFORM_FSP_BIN_PACKAGE)/Fsp_Rebased_S_padded.fd
}

[FV.FVRECOVERY3_COMPACT]
BlockSize     = $(FLASH_BLOCK_SIZE)
FvAlignment        = 16
ERASE_POLARITY     = 1
MEMORY_MAPPED      = TRUE
STICKY_WRITE       = TRUE
LOCK_CAP           = TRUE
LOCK_STATUS        = TRUE
WRITE_DISABLED_CAP = TRUE
WRITE_ENABLED_CAP  = TRUE
WRITE_STATUS       = TRUE
WRITE_LOCK_CAP     = TRUE
WRITE_LOCK_STATUS  = TRUE
READ_DISABLED_CAP  = TRUE
READ_ENABLED_CAP   = TRUE
READ_STATUS        = TRUE
READ_LOCK_CAP      = TRUE
READ_LOCK_STATUS   = TRUE

FILE FV_IMAGE = 244FAAF4-FAE1-4892-8B7D-7EF84CBFA709 {
!if $(TARGET) == DEBUG
      SECTION GUIDED EE4E5898-3914-4259-9D6E-DC7BD79403CF PROCESSING_REQUIRED = TRUE {
        SECTION FV_IMAGE = FVRECOVERY3
      }
!else
    SECTION FV_IMAGE = FVRECOVERY3
!endif
}

[FV.FVRECOVERY3]
BlockSize     = $(FLASH_BLOCK_SIZE)
FvAlignment        = 16         #FV alignment and FV attributes setting.
ERASE_POLARITY     = 1
MEMORY_MAPPED      = TRUE
STICKY_WRITE       = TRUE
LOCK_CAP           = TRUE
LOCK_STATUS        = TRUE
WRITE_DISABLED_CAP = TRUE
WRITE_ENABLED_CAP  = TRUE
WRITE_STATUS       = TRUE
WRITE_LOCK_CAP     = TRUE
WRITE_LOCK_STATUS  = TRUE
READ_DISABLED_CAP  = TRUE
READ_ENABLED_CAP   = TRUE
READ_STATUS        = TRUE
READ_LOCK_CAP      = TRUE
READ_LOCK_STATUS   = TRUE
FvNameGuid         = 8579D1CA-45E8-4f1c-A789-FFA770672099

################################################################################
#
# The INF statements point to EDK component and EDK II module INF files, which will be placed into this FV image.
# Parsing tools will scan the INF file to determine the type of component or module.
# The component or module type is used to reference the standard rules
# defined elsewhere in the FDF file.
#
# The format for INF statements is:
# INF $(PathAndInfFileName)
#
################################################################################


# Init Board Config PCD
INF $(PLATFORM_PACKAGE)/PlatformInit/PlatformInitPei/PlatformInitPostMem.inf

INF IntelFsp2WrapperPkg/FspsWrapperPeim/FspsWrapperPeim.inf

!include $(PLATFORM_PACKAGE)/Include/Fdf/CorePeiPostMemInclude.fdf

!if gSiPkgTokenSpaceGuid.PcdPeiDisplayEnable == TRUE
FILE FREEFORM = 4ad46122-ffeb-4a52-bfb0-518cfca02db0 {
  SECTION RAW = $(PLATFORM_FSP_BIN_PACKAGE)/SampleCode/Vbt/Vbt.bin
  SECTION UI  = "Vbt"
}
FILE FREEFORM = 7BB28B99-61BB-11D5-9A5D-0090273FC14D {
  SECTION RAW = MdeModulePkg/Logo/Logo.bmp
}
!endif # PcdPeiDisplayEnable


[FV.FVRECOVERY2]
BlockSize     = $(FLASH_BLOCK_SIZE)
FvAlignment        = 16         #FV alignment and FV attributes setting.
ERASE_POLARITY     = 1
MEMORY_MAPPED      = TRUE
STICKY_WRITE       = TRUE
LOCK_CAP           = TRUE
LOCK_STATUS        = TRUE
WRITE_DISABLED_CAP = TRUE
WRITE_ENABLED_CAP  = TRUE
WRITE_STATUS       = TRUE
WRITE_LOCK_CAP     = TRUE
WRITE_LOCK_STATUS  = TRUE
READ_DISABLED_CAP  = TRUE
READ_ENABLED_CAP   = TRUE
READ_STATUS        = TRUE
READ_LOCK_CAP      = TRUE
READ_LOCK_STATUS   = TRUE
FvNameGuid         = B73FE497-B92E-416e-8326-45AD0D270091

################################################################################
#
# The INF statements point to EDK component and EDK II module INF files, which will be placed into this FV image.
# Parsing tools will scan the INF file to determine the type of component or module.
# The component or module type is used to reference the standard rules
# defined elsewhere in the FDF file.
#
# The format for INF statements is:
# INF $(PathAndInfFileName)
#
################################################################################
  ##
  #  PEI Apriori file example, more PEIM module added later.
  ##
APRIORI PEI {
}

  ##
  #  PEI Phase modules
  ##
  
INF $(PLATFORM_PACKAGE)/PlatformInit/PlatformInitPei/PlatformInitPreMem.inf

!include $(PLATFORM_PACKAGE)/Include/Fdf/CorePeiPreMemInclude.fdf

!if gPlatformModuleTokenSpaceGuid.PcdTpm2Enable == TRUE
INF $(PLATFORM_PACKAGE)/Tcg/Tcg2PlatformPei/Tcg2PlatformPei.inf
!endif

INF IntelFsp2WrapperPkg/FspmWrapperPeim/FspmWrapperPeim.inf

[FV.FVRECOVERY]
BlockSize     = $(FLASH_BLOCK_SIZE)
FvAlignment        = 16         #FV alignment and FV attributes setting.
ERASE_POLARITY     = 1
MEMORY_MAPPED      = TRUE
STICKY_WRITE       = TRUE
LOCK_CAP           = TRUE
LOCK_STATUS        = TRUE
WRITE_DISABLED_CAP = TRUE
WRITE_ENABLED_CAP  = TRUE
WRITE_STATUS       = TRUE
WRITE_LOCK_CAP     = TRUE
WRITE_LOCK_STATUS  = TRUE
READ_DISABLED_CAP  = TRUE
READ_ENABLED_CAP   = TRUE
READ_STATUS        = TRUE
READ_LOCK_CAP      = TRUE
READ_LOCK_STATUS   = TRUE
FvNameGuid         = BA34AA5B-110E-4B10-B729-E559EFD075D3

!include $(PLATFORM_PACKAGE)/Include/Fdf/CorePeiBfvInclude.fdf


[FV.FVMAIN2]
BlockSize          = $(FLASH_BLOCK_SIZE)
FvForceRebase      = FALSE
FvAlignment        = 16
ERASE_POLARITY     = 1
MEMORY_MAPPED      = TRUE
STICKY_WRITE       = TRUE
LOCK_CAP           = TRUE
LOCK_STATUS        = TRUE
WRITE_DISABLED_CAP = TRUE
WRITE_ENABLED_CAP  = TRUE
WRITE_STATUS       = TRUE
WRITE_LOCK_CAP     = TRUE
WRITE_LOCK_STATUS  = TRUE
READ_DISABLED_CAP  = TRUE
READ_ENABLED_CAP   = TRUE
READ_STATUS        = TRUE
READ_LOCK_CAP      = TRUE
READ_LOCK_STATUS   = TRUE
FvNameGuid         = B92CF322-8AFA-4aa4-B946-005DF1D69778


#INF ShellBinPkg/UefiShell/UefiShell.inf


[FV.FVMAIN2_COMPACT]
BlockSize     = $(FLASH_BLOCK_SIZE)
FvAlignment        = 16
ERASE_POLARITY     = 1
MEMORY_MAPPED      = TRUE
STICKY_WRITE       = TRUE
LOCK_CAP           = TRUE
LOCK_STATUS        = TRUE
WRITE_DISABLED_CAP = TRUE
WRITE_ENABLED_CAP  = TRUE
WRITE_STATUS       = TRUE
WRITE_LOCK_CAP     = TRUE
WRITE_LOCK_STATUS  = TRUE
READ_DISABLED_CAP  = TRUE
READ_ENABLED_CAP   = TRUE
READ_STATUS        = TRUE
READ_LOCK_CAP      = TRUE
READ_LOCK_STATUS   = TRUE

FILE FV_IMAGE = 4E35FD93-9C72-4c15-8C4B-E77F1DB2D792 {
      SECTION GUIDED EE4E5898-3914-4259-9D6E-DC7BD79403CF PROCESSING_REQUIRED = TRUE {
        SECTION FV_IMAGE = FVMAIN2
      }
}

[FV.FVMAIN]
BlockSize     = $(FLASH_BLOCK_SIZE)
FvAlignment        = 16
ERASE_POLARITY     = 1
MEMORY_MAPPED      = TRUE
STICKY_WRITE       = TRUE
LOCK_CAP           = TRUE
LOCK_STATUS        = TRUE
WRITE_DISABLED_CAP = TRUE
WRITE_ENABLED_CAP  = TRUE
WRITE_STATUS       = TRUE
WRITE_LOCK_CAP     = TRUE
WRITE_LOCK_STATUS  = TRUE
READ_DISABLED_CAP  = TRUE
READ_ENABLED_CAP   = TRUE
READ_STATUS        = TRUE
READ_LOCK_CAP      = TRUE
READ_LOCK_STATUS   = TRUE
FvNameGuid         = A881D567-6CB0-4eee-8435-2E72D33E45B5

  ##
  #  DXE Apriori file example, more DXE module added later.
  ##

APRIORI DXE {
}

  ##
  #  DXE Phase modules
  ##

!include $(PLATFORM_PACKAGE)/Include/Fdf/CoreDxeInclude.fdf

INF  $(PLATFORM_PACKAGE)/PlatformInit/PlatformInitDxe/PlatformInitDxe.inf

!if gPlatformModuleTokenSpaceGuid.PcdBootToShellOnly == FALSE
INF  $(PLATFORM_BOARD_PACKAGE)/Policy/PolicyInitDxe/PolicyInitDxe.inf

$(SIPKG_DXE_SMM_BIN) $(PLATFORM_SI_PACKAGE)/Pch/PchInit/Dxe/PchInitDxe.inf
$(SIPKG_DXE_SMM_BIN) $(PLATFORM_SI_PACKAGE)/SystemAgent/SaInit/Dxe/SaInitDxe.inf

INF  $(PLATFORM_PACKAGE)/PlatformInit/PlatformInitSmm/PlatformInitSmm.inf
$(SIPKG_DXE_SMM_BIN) $(PLATFORM_SI_PACKAGE)/SystemAgent/SmmAccess/Dxe/SmmAccess.inf

$(SIPKG_DXE_SMM_BIN) $(PLATFORM_SI_PACKAGE)/Pch/PchSmiDispatcher/Smm/PchSmiDispatcher.inf
$(SIPKG_DXE_SMM_BIN) $(PLATFORM_SI_PACKAGE)/Pch/SmmControl/RuntimeDxe/SmmControl.inf
$(SIPKG_DXE_SMM_BIN) $(PLATFORM_SI_PACKAGE)/Pch/Spi/Smm/PchSpiSmm.inf
$(SIPKG_DXE_SMM_BIN) $(PLATFORM_SI_PACKAGE)/Pch/PchInit/Smm/PchInitSmm.inf

INF  $(PLATFORM_PACKAGE)/Flash/SpiFvbService/SpiFvbServiceSmm.inf
!endif

!if gPlatformModuleTokenSpaceGuid.PcdBootToShellOnly == FALSE
INF $(PLATFORM_PACKAGE)/Acpi/AcpiTables/AcpiPlatform.inf
INF RuleOverride = DRIVER_ACPITABLE $(PLATFORM_BOARD_PACKAGE)/Acpi/BoardAcpiDxe/BoardAcpiDxe.inf
INF $(PLATFORM_PACKAGE)/Acpi/AcpiSmm/AcpiSmm.inf

INF  RuleOverride = ACPITABLE $(PLATFORM_SI_PACKAGE)/SystemAgent/AcpiTables/SaAcpiTables.inf
INF  RuleOverride = ACPITABLE $(PLATFORM_SI_PACKAGE)/SystemAgent/AcpiTables/SaSsdt/SaSsdt.inf

INF  $(PLATFORM_PACKAGE)/FspWrapper/SaveMemoryConfig/SaveMemoryConfig.inf

INF $(PLATFORM_SI_PACKAGE)/Hsti/Dxe/HstiSiliconDxe.inf

INF $(PLATFORM_PACKAGE)/Hsti/HstiIbvPlatformDxe/HstiIbvPlatformDxe.inf

!endif

INF  IntelFsp2WrapperPkg/FspWrapperNotifyDxe/FspWrapperNotifyDxe.inf

!if gPlatformModuleTokenSpaceGuid.PcdTpm2Enable == TRUE
INF $(PLATFORM_PACKAGE)/Tcg/Tcg2PlatformDxe/Tcg2PlatformDxe.inf
!endif

INF  IntelSiliconPkg/IntelVTdDxe/IntelVTdDxe.inf

INF ShellBinPkg/UefiShell/UefiShell.inf

[FV.FVMAIN_COMPACT]
BlockSize     = $(FLASH_BLOCK_SIZE)
FvAlignment        = 16
ERASE_POLARITY     = 1
MEMORY_MAPPED      = TRUE
STICKY_WRITE       = TRUE
LOCK_CAP           = TRUE
LOCK_STATUS        = TRUE
WRITE_DISABLED_CAP = TRUE
WRITE_ENABLED_CAP  = TRUE
WRITE_STATUS       = TRUE
WRITE_LOCK_CAP     = TRUE
WRITE_LOCK_STATUS  = TRUE
READ_DISABLED_CAP  = TRUE
READ_ENABLED_CAP   = TRUE
READ_STATUS        = TRUE
READ_LOCK_CAP      = TRUE
READ_LOCK_STATUS   = TRUE

FILE FV_IMAGE = 9E21FD93-9C72-4c15-8C4B-E77F1DB2D792 {
       SECTION GUIDED EE4E5898-3914-4259-9D6E-DC7BD79403CF PROCESSING_REQUIRED = TRUE {
         SECTION FV_IMAGE = FVMAIN
       }
     }

################################################################################
#
# Rules are use with the [FV] section's module INF type to define
# how an FFS file is created for a given INF file. The following Rule are the default
# rules for the different module type. User can add the customized rules to define the
# content of the FFS file.
#
################################################################################

!include $(PLATFORM_PACKAGE)/Include/Fdf/RuleInclude.fdf

